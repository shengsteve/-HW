<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        #info {
            position: absolute;
            top: 0px;
            width: 100%;
            padding: 10px;
            text-align: center;
            color: #ffff00;
          }
          
          body {
            overflow: hidden;
          }
    </style>

</head>
<body>
    <div id="info">GameProg3JS HW1 
    </div>
	
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script>
    <script src="https://threejs.org/build/three.min.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
	<script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/loaders/OBJLoader.js"></script>
    <script>
        var camera ,renderer,scene,controls,car,othcam,body,angle=0;

        class Cylinderlocal{
		constructor(x,y,z,rad){
		this.x=x;
		this.y=y;
		this.z=z;
		this.rad=rad;
		}
}		 
		var cylinders=[];
		(function() {
		Math.clamp = function(val,min,max){
        return Math.min(Math.max(val,min),max);
		}})();
		
		init();
        animate();
	
		function loadCubemap() {

        var path ="map/"
        var format = '.jpg';

        var urls = [
            path + 'posy' + format, path + 'posy' + format,
            path + 'posy' + format, path + 'negy' + format,
            path + 'posy' + format, path + 'posy' + format
        ];


        var loader = new THREE.CubeTextureLoader();
        loader.setCrossOrigin ('');
        
		var cubeMap = loader.load(urls);
        cubeMap.format = THREE.RGBFormat;
        return cubeMap;

        }

        function init(){
            //////////////////////////////////////////  new scene camera
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(50,window.innerWidth/window.innerHeight,1,1000);
          
            othcam = new THREE.PerspectiveCamera(50,window.innerWidth/window.innerHeight,1,1000);

            //var ground = new THREE.GridHelper(200,20,'red','white');
            //scene.add(ground);
            
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth,window.innerHeight);
            renderer.setClearColor('gray');
            
            document.body.appendChild(renderer.domElement);
            
            controls = new THREE.OrbitControls(camera,renderer.domElement);
            
            ////////////////////////////////////////////  obj
            car = new THREE.Group();
            readModel('cars');
            scene.add(car);
            car.position.set(0,0,0);
            ////////////////////////////////////////////  render
            renderer.autoClear =false;

            /////////////////////////////////////////// light
            var geometry = new THREE.CylinderBufferGeometry( 5, 5, 20, 32 );
			var material = new THREE.MeshNormalMaterial( {color: 0x888800} );
			for(var i=0;i<5;i++){
			var size =Math.random()*8+4;
			var geometry = new THREE.CylinderBufferGeometry( size, size, 20, 32 );
			var material = new THREE.MeshPhongMaterial( {color: 0x888800} );
			var cylinder = new THREE.Mesh( geometry, material );
			var posnegx = Math.random() >0.5 ? 1:-1;
			var posnegz = Math.random() >0.5 ? 1:-1;
			cylinder.position.set(Math.random()*200*posnegx,10,Math.random()*200*posnegz);
			if(cylinder.position.x<-10&&cylinder.position.x>-90&&cylinder.position.z<30&&cylinder.position.z>-30){
                i--;
            continue;
			}
			cylinders.push(new Cylinderlocal(cylinder.position.x,cylinder.position.y,cylinder.position.z,size));
			scene.add( cylinder );
			}
			
			
			
			
			var light = new THREE.PointLight( 0xffffff, 1, 300 );
            var light2 = new THREE.PointLight( 0xffffff, 1, 300 );
            var light3 = new THREE.PointLight( 0xffffff, 1, 300 );
            var light4 = new THREE.PointLight( 0xffffff, 1, 300 );
            light.position.set( -80, 100, 0 );
            light2.position.set( 80, 100, 0 );
            light3.position.set( 0, 100, 80 );
            light4.position.set( 0, 100, -80 );
            scene.add(light,light2,light3,light4);

            ////////////////////////////////////////// texture
            let loader = new THREE.TextureLoader()
            loader.crossOrigin = '';
            texture = loader.load('https://i.imgur.com/81hHjZB.jpg');
            texture.repeat.set(1, 1);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            mesh = new THREE.Mesh(new THREE.PlaneGeometry(400, 400),
            new THREE.MeshBasicMaterial({
                map: texture
            }))
            mesh.rotation.x = -Math.PI / 2;
            scene.add(mesh);

            /////////////////////////////////////// car body
            

            /////////////////////////////////////// cubemap
            var cubeMap = loadCubemap();
            scene.background = cubeMap;

        }
        function readModel (modelName, targetSize=30) {

            var onProgress = function(xhr) {
            if (xhr.lengthComputable) {
                var percentComplete = xhr.loaded / xhr.total * 100;
                console.log(Math.round(percentComplete, 2) + '% downloaded');
            }
            };

            var onError = function(xhr) {};

            var mtlLoader = new THREE.MTLLoader();
            //mtlLoader.setPath('model/');
            mtlLoader.load(modelName+'.mtl', function(materials) {

            materials.preload();

            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            //objLoader.setPath('model/');
            objLoader.load(modelName+'.obj', function(object) {
                
                let theObject =  unitize (object, targetSize);
                theObject.name = 'OBJ'
                car.add (theObject);
                
                theObject.setRotationFromEuler (new THREE.Euler (3.1416/2, 0, -3.1416/2, 'ZYX'))

            }, onProgress, onError);

            });

        }

        function unitize (object, targetSize) {  

            // find bounding box of 'object'
            var box3 = new THREE.Box3();
            box3.setFromObject (object);
            var size = new THREE.Vector3();
            size.subVectors (box3.max, box3.min);
            var center = new THREE.Vector3();
            center.addVectors(box3.max, box3.min).multiplyScalar (0);
            
            console.log ('center: ' + center.x + ', '+center.y + ', '+center.z );
            console.log ('size: ' + size.x + ', ' +  size.y + ', '+size.z );
            
            // uniform scaling according to objSize
            var objSize = Math.max (size.x, size.y, size.z);
            var scaleSet = targetSize/objSize;
                    
            var theObject =  new THREE.Object3D();
            theObject.add (object);
            object.scale.set (scaleSet, scaleSet, scaleSet);
            object.position.set (-center.x*scaleSet, -center.y*scaleSet, -center.z*scaleSet);
            object.rotation.z=Math.PI/2;
            object.rotation.x-=Math.PI/1.5;
			
			object.position.x-=4;
			object.position.y=10;

            
            
            return theObject;
            
        }
        function animate(){
            angle +=0.01;
            car.position.set(60*Math.cos(angle),0,60*Math.sin(angle));
            car.rotation.y=-(Math.PI+angle);
            requestAnimationFrame(animate);
            render();
        }

        function render(){
            renderer.clear();
            let IW = window.innerWidth;
            let IH = window.innerHeight;
            renderer.setViewport(0,0,IW/2,IH);
            camera.aspect=IW/2/IH;
            camera.updateProjectionMatrix();
            let carpos = car.localToWorld(new THREE.Vector3(-5,10,50));
            camera.position.copy(carpos);
            camera.lookAt(car.position);
            renderer.render(scene,camera);
            ///////////////////////////// othe viewport
            renderer.setViewport(IW/2,0,IW/2,IH);
            othcam.aspect=IW/2/IH;
            othcam.updateProjectionMatrix(); 
            othcam.position.set(car.position.x,100,car.position.z);
            othcam.lookAt(car.position);
            renderer.render(scene,othcam);          
            

        }       

    </script>
</body>
</html>